---
title: 'RSA暗号の仕組みについて'
date: '2025/01/18'
read_time : '30m'
image: '/profile.png'
description: 'RSA暗号の仕組みと簡単なCTF問題'
category: 'security'
published: true
---

## はじめに
CTFをやる中で，少しは暗号に触れるようになってきたので，頻出のテーマであるRSA暗号について少し勉強してみました．

## RSA暗号(safeprime)
RSA暗号とは暗号化に使う鍵と復号に使う鍵が異なる公開鍵暗号方式の一つであり，1977年にRivest(リベスト)，Shamir(シャミア)，Adleman(エーデルマン)によって考案された，桁数がとても多い数字に対する素因数分解が困難であることを利用した暗号方式です．
これらの開発者の頭文字からRSA暗号と命名されました．

## 使われる式について
### 最小公倍数
任意の整数$a,b$に対して最小の公倍数のこと．
(例)$LCM(3,4)=12$

### 最大公約数
任意の整数$a,b$に対して最大の公約数のこと．$GCD(a,b)$と表す．
$GCD(a,b)=1$の場合，整数$a,b$は互いに素である．
(例)$GCD(12,18)=6$

### モジュロ演算(合同式)
整数$a$，$b$，$n$に対して，「$a$を$n$で割った余り」と「$b$を$n$で割った余り」が等しいとき，
$a \equiv b~(mod~n)$と表す.（$a$ は $n$を法として$b$と合同である.）
（例）$11$ $\equiv$ $3$ (mod $4$)

### 逆元(モジュラ逆数)
$n$を法として，ある整数$a$に対して，$ax \equiv 1~(mod~p)$が成立するような数$x$のこと.
これは[拡張ユークリッド互除法](https://qiita.com/drken/items/b97ff231e43bce50199a)で求めることができる．
＊$x=a^{-1}$みたいな感じ？

### オイラー関数
$n$を超えない正の整数のうち$n$と互いに素である数の個数のこと．$\phi(n)$と書く．
例えば$\phi(6)~=[1,5]~=2$となる．
$n$が素数である場合，$\phi(n)~=~n-1$となる．

### フェルマーの小定理
素数$p$と互いに素な整数$a$において
$a^{p-1}=1~mod~p$が成り立つ．

### オイラーの定理
整数$m$と互いに素な整数$a$において
$a^{\phi(m)}=1~mod~m$

## 鍵の生成方法
異なる大きな2つの素数$p,q$を生成する．
$n=pq$とする．
$\phi(n) = (p-1)(q-1)$とする．
$GCD(\phi(n),e)=1$となるような自然数$e$を生成する($\phi(n)$と$e$は互いに素である)．
＊その場合$\phi(pq)=\phi(p)~\phi(q)$が成り立つ．
$ed ≡ 1~mod~\phi(n)$となるような$d$を求める（ここでモジュラ逆数の話が出てきます）．
＊$ed$を$\phi(n)$で割ったときの余りが$1$になる．
この$d$を求めるには拡張ユークリッド互除法を用いて求めることができます．
ここで$GCD(\phi(n),e)=1$であるため，$\phi(n)x+ey=GCD(\phi(n),e)=1$を解き，$d$を求めます．
最終的に公開鍵は$(e,n)$，秘密鍵は$(d,n)$となります．

## 暗号化方法
送りたいメッセージを$M$，暗号文$C$とすると以下の式で暗号化をすることができる．
$C ≡ M^e~mod~n$

## 復号化方法
$C^d~mod~n ≡ x$
ここで$d$を求めるには$p$と$q$を知る必要がある．$p \times q$によって計算される$n$は公開されているが，$n$は巨大な数の合成数であり，これを素因数分解するのは困難であるという部分にRSA暗号の解読困難な性質が保証されています．
（＊そう考えてみると「サマーウォーズ」で主人公がやっていたことがどれだけありえないことなのかがわかりますね）

## CTFで出題された問題を解いてみる
ここからは上記で述べたRSA暗号を用いてCTFの問題を解いてみたいと思います．
今回は[WaniCTF 2024](https://wanictf.org/jp.html)で出題されたbeginners_rsaを解いてみたいと思います．

### 問題の概要
以下のようなchall.pyというpythonファイルとこのファイルを実行した結果得られるoutput.txtが配布されます．
```
# chall.py
from Crypto.Util.number import *

p = getPrime(64)
q = getPrime(64)
r = getPrime(64)
s = getPrime(64)
a = getPrime(64)
n = p*q*r*s*a
e = 0x10001

FLAG = b'FLAG{This_is_a_fake_flag}'
m = bytes_to_long(FLAG)
enc = pow(m, e, n)
print(f'n = {n}')
print(f'e = {e}')
print(f'enc = {enc}')
```

```
# output.txt

n = 317903423385943473062528814030345176720578295695512495346444822768171649361480819163749494400347
e = 65537
enc = 127075137729897107295787718796341877071536678034322988535029776806418266591167534816788125330265
```

### 回答
ここでまずchall.pyで何をしているかというと，

- getprime関数で64bitの素数を取得
- 生成した素数をすべて乗算する（ここで$n$を求めています．上の説明では$p$と$q$の2つでしたがここでは5つの数を用いています．）
- $e$は*0x10001*と設定されています．（慣例的に0x10001=65537が用いられるようです．）
- これらを用いて暗号化しています．ここで`pow(m, e, n)`は$m^e~mod~n$という意味です．

output.txtに出力された情報をもとに復号してみます．

- まず$p,q,r,s,a$を知るために，$n$を素因数分解します．今回は64bitなので解読可能です．
- 素因数分解して得られた$p,q,r,s,a$を用いて$\phi(n)$を求めます．
- ここで，$e$と$\phi(n)$がわかっているので，そこから$d$の値を求めます．

これらをソースコードにすると以下のようになります.

```
from Crypto.Util.number import *
import pdb
from sympy.ntheory import factorint

n = 317903423385943473062528814030345176720578295695512495346444822768171649361480819163749494400347
e = 65537
enc = 127075137729897107295787718796341877071536678034322988535029776806418266591167534816788125330265

# factors = list(factorint(n).keys())

p = factors[0]
q = factors[1]
r = factors[2]
s = factors[3]
a = factors[4]

phi = (p-1)*(q-1)*(r-1)*(s-1)*(a-1)
d = pow(e, -1, phi)

m = pow(enc,d,n)
flag = long_to_bytes(m).decode()
print(flag)
```

# 参考
- RSA暗号を支える数学，Qiita
  - https://qiita.com/momochanjazz/items/9314a8c965d6be6563a9
- 拡張ユークリッドの互除法，Qiita
  - https://qiita.com/drken/items/b97ff231e43bce50199a
- 暗号技術のすべて，IPUSIRON著
  - https://www.amazon.co.jp/%E6%9A%97%E5%8F%B7%E6%8A%80%E8%A1%93%E3%81%AE%E3%81%99%E3%81%B9%E3%81%A6-IPUSIRON/dp/4798148814